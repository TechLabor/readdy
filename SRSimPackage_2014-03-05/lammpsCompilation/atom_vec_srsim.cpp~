/* ----------------------------------------------------------------------
			atom_vec_srsim
------------------------------------------------------------------------- */

#include "stdlib.h"
#include "atom_vec_srsim.h"
#include "atom.h"
#include "domain.h"
#include "modify.h"
#include "fix.h"
#include "memory.h"
#include "error.h"
#include "comm.h"
#include "update.h"

#include <SRSim/defs.h>
#include <assert.h>
#include <SRSim/molecule_type_manager.h>
#include <SRSim/bng_rule_builder.h>
#include <SRSim/names_manager.h>
#include <SRSim/molecule_type_manager.h>

#include "lammps_molecule.h"

using namespace LAMMPS_NS;

#define DELTA 10000

bool   AtomVecSRSim::restartInfoAvail = false;
string AtomVecSRSim::SRSimBnglName;
string AtomVecSRSim::SRSimMgeoName;
string AtomVecSRSim::SRSimTgeoName;
int    AtomVecSRSim::rndSeed;

/* ---------------------------------------------------------------------- */

AtomVecSRSim::AtomVecSRSim(LAMMPS *lmp, int narg, char **arg) :
  SUPERCLASS(lmp, narg, arg)
  {
  printf ("AtomVecSRSim::AtomVecSRSim \n");
  
  mol_Id_Cnt            = 0;
  rigid_system          = false;
  
  site_bound_tag        = NULL;
  site_other_site       = NULL;
  site_bond_id          = NULL;
  site_modified         = NULL;
  visited               = NULL;
  refractory            = NULL;
  
  srmodel               = NULL;
  rset                  = NULL;
  
  // this seems to be the best time/space to init the rule-System: 
  //    (We need to know how the atoms look when we create them!)    
  if (narg == 0 && restartInfoAvail == true )
     {
     printf ("initing AtomVecSRSim for a restart!!\n");
     setRuleSys( new SRSim_ns::SRModel( rndSeed, SRSimBnglName.c_str(), SRSimMgeoName.c_str(), SRSimTgeoName.c_str(), true/*add Zero Species*/) );
     }
  else if (narg == 4)
     {
     setRuleSys( new SRSim_ns::SRModel( atoi(arg[3])/*random seed*/, arg[0], arg[1], arg[2], true/*add Zero Species*/) );
     }
  else error->all("AtomVecSRSim::AtomVecSRSim: atom_style srsim needs four params. <bnglName, mgeoName, tgeoName, rndSeed> ... look for runmodif_srsim if in trouble.");
  
  printf ("AtomVecSRSim::AtomVecSRSim: Construction finished! (SRSim was written with a carrot in one hand.)\n");
  }

/* ---------------------------------------------------------------------- */

/** using the constructor alone does not suffice to initiate the
    SRSim-Atom-Vector. 
    The Lammps-Command runModifSRSim has to be used to create a
    rule model!
 */
void AtomVecSRSim::setRuleSys( SRSim_ns::SRModel *_srmodel )
  {
  srmodel = _srmodel;
  rset    = srmodel->ruleset;
  
  // as we know the number of templates now, we can init the amount_templs - array.
  amount_templs.resize (rset->numTemplates());
  
  // we will now create the type2numSites array here.
  SRSim_ns::MoleculeTypeManager *mtm = srmodel->mtm;
  int numMolIDs = mtm->numMolIDs();
  type2numSites = new int [numMolIDs];   // reserve mem
  for (int i=0 ; i<numMolIDs ; i++)
      type2numSites[i] = mtm->numSites(i);
      
  // as we've got the mtm now, we can init the Lammps-Molecules:
  LammpsMolecule::init(atom, this);
  //printf ("Ping6\n");
  
  
  printf ("Done setting the Rule System.\n");
  }

/* ---------------------------------------------------------------------- */

AtomVecSRSim::~AtomVecSRSim()
{
  printf("Destruction! [AtomVecSRSim::~AtomVecSRSim]\n");
  // template-arrays:
  /*amount_templs.clear();
  delete[] all_templs;
  for (int i=0 ; i<nmax ; i++)
      delete[] site_templs[i];*/
  
  //num_fitting_overall = 0;
  
  /*free (num_fitting_templates);  num_fitting_templates=NULL;
  for (int i=0 ; i<nmax ; i++)
      if (fitting_templates[i]!=NULL) free( fitting_templates[i] );
  free (fitting_templates    );  fitting_templates    =NULL;*/
  
  delete[] type2numSites; type2numSites = NULL;
  // delete site-specific arrays
  int &nlocal = atom->nlocal;
  if (site_bound_tag != NULL) 
     { for (int i=0 ; i<nlocal ; i++) free (site_bound_tag [i]); free (site_bound_tag); }
  if (site_bond_id != NULL) 
     { for (int i=0 ; i<nlocal ; i++) free (site_bond_id   [i]); free (site_bond_id); }
  if (site_other_site != NULL) 
     { for (int i=0 ; i<nlocal ; i++) free (site_other_site[i]); free (site_other_site); }
  if (site_modified != NULL) 
     { for (int i=0 ; i<nlocal ; i++) free (site_modified  [i]); free (site_modified); }
  
  delete[] visited;    visited = NULL;
  delete[] refractory; refractory = NULL;
  refractoryList.clear();
  
  LammpsMolecule::staticDelete();
  
  // TODO: Check that the arrays (fitting_templates, site_bound_to and site_modified)
  //       are all reserved or NULL when not...!
}


/* ----------------------------------------------------------------------
   grow atom arrays
   n = 0 grows arrays by DELTA
   n > 0 allocates arrays to size n 
------------------------------------------------------------------------- */

void AtomVecSRSim::grow(int n)
{
  printf ("AtomVecSRSim:::grow\n", nmax);
  if (srmodel == NULL)
     error->all("The rule system is not initialized yet: use runmodif_srsim ruleSys first! (e.g. runmodif_srsim ruleSys spass.bngl spass.geo spass.tgeo 12345)");

  printf ("grow AtomVecSRSim %d!\n",n);
  SUPERCLASS::grow(n);
  printf ("...grow AtomVecSRSim %d!\n",nmax);

  visited         = (int*) realloc ( visited        , nmax*sizeof(int ));
  refractory      = (int*) realloc ( refractory     , nmax*sizeof(int ));
  site_bound_tag  = (int**)realloc ( site_bound_tag , nmax*sizeof(int*));
  site_modified   = (int**)realloc ( site_modified  , nmax*sizeof(int*));
  site_bond_id    = (int**)realloc ( site_bond_id   , nmax*sizeof(int*));
  site_other_site = (int**)realloc ( site_other_site, nmax*sizeof(int*));
  
  site_templs.resize(nmax);
   all_templs.resize(nmax);
   
  LammpsMolecule::grow(nmax);
  
  printf ("AtomVecSRSim grown to nmax=%d!\n", nmax);
}

/* ---------------------------------------------------------------------- */

// void AtomVecSRSim::reset_special()
// {
//   SUPERCLASS::reset_special();
// }

/* ---------------------------------------------------------------------- */

void AtomVecSRSim::copy(int i, int j)   // i --> j
{
  SUPERCLASS::copy(i, j);
  
  printf ("AtomVecSRSim::copy %d -> %d\n",i,j);
  
  // subtract from amount_templs what has been in j:
  for (int ii=0 ; ii<all_templs[j].size() ; ii++) amount_templs[ all_templs[j][ii] ]--;

  // fitting templates...  
  site_templs[j] = site_templs[i];
   all_templs[j] =  all_templs[i];

  // add to amount_templs what will be in j:
  for (int ii=0 ; ii<all_templs[j].size() ; ii++) amount_templs[ all_templs[j][ii] ]++;
  
  // site arrays kopieren.
  int numSites = type2numSites[atom->type[j]];
  site_bound_tag [j] = (int*) realloc (site_bound_tag [j], sizeof(int)*numSites);
  site_modified  [j] = (int*) realloc (site_modified  [j], sizeof(int)*numSites);
  site_bond_id   [j] = (int*) realloc (site_bond_id   [j], sizeof(int)*numSites);
  site_other_site[j] = (int*) realloc (site_other_site[j], sizeof(int)*numSites);
  for (int ii=0 ; ii<numSites ; ii++)
      {
      site_bound_tag [j][ii] = site_bound_tag [i][ii];
      site_modified  [j][ii] = site_modified  [i][ii];
      site_bond_id   [j][ii] = site_bond_id   [i][ii];
      site_other_site[j][ii] = site_other_site[i][ii];
      }
      
  // visitation:       // I don't think we should have to use this:
  assert( visited[j] == -1 && visited[i] == -1 );    // if this hurts, uncomment the next line:
  //visited[j] = visited[i];
  
  assert( refractory[i]==-1 );   // otherwise we'd have to adjust the refractoryList as well!
  assert( refractory[j]==-1 );
}

/* ---------------------------------------------------------------------- */

int AtomVecSRSim::pack_comm(int n, int *list, double *buf,
			    int pbc_flag, int *pbc)
{
  //printf ("A\n");
  return SUPERCLASS::pack_comm(n,list,buf,pbc_flag,pbc);
}

/* ---------------------------------------------------------------------- */

void AtomVecSRSim::unpack_comm(int n, int first, double *buf)
{
  //printf ("B\n");
  SUPERCLASS::unpack_comm(n, first, buf);
}

/* ---------------------------------------------------------------------- */

int AtomVecSRSim::pack_reverse(int n, int first, double *buf)
{
  //printf ("C\n");
  SUPERCLASS::pack_reverse (n,first, buf);
}

/* ---------------------------------------------------------------------- */

void AtomVecSRSim::unpack_reverse(int n, int *list, double *buf)
{
  //printf ("D\n");
  SUPERCLASS::unpack_reverse (n,list,buf);
}

/* ---------------------------------------------------------------------- */

// seems as we don't have to pack the fitting template - Info: Bond and Angle 
// info aren't communicated either...
int AtomVecSRSim::pack_border(int n, int *list, double *buf,
			      int pbc_flag, int *pbc)
{
  //printf ("E\n");
  return SUPERCLASS::pack_border(n,list,buf,pbc_flag,pbc);
}

/* ---------------------------------------------------------------------- */

int AtomVecSRSim::pack_border_one(int i, double *buf)
{
  //printf ("F\n");
  return SUPERCLASS::pack_border_one(i,buf);
}

/* ---------------------------------------------------------------------- */

void AtomVecSRSim::unpack_border(int n, int first, double *buf)
{
  //printf ("G\n");
  SUPERCLASS::unpack_border(n,first,buf);
}

/* ---------------------------------------------------------------------- */

int AtomVecSRSim::unpack_border_one(int i, double *buf)
{
  //printf ("H\n");
  return SUPERCLASS::unpack_border_one(i,buf);
}

/* ----------------------------------------------------------------------
   pack data for atom I for sending to another proc
   xyz must be 1st 3 values, so comm::exchange() can test on them 
------------------------------------------------------------------------- */

int AtomVecSRSim::pack_exchange(int i, double *buf)
{
  int m = SUPERCLASS::pack_exchange(i,buf);
  printf ("I = %d    nlocal=%d     ts = %d\n",i,atom->nlocal, update->ntimestep);
  assert(false);
  
  // ############
  
  
  // subtract from amount_templs what has been in j:
  for (int ii=0 ; ii<all_templs[i].size() ; ii++) amount_templs[ all_templs[i][ii] ]--;

  // fitting templates...  
  printf (" A  m = %d\n",m);
  int num2;
  int num1 = buf[m++] = site_templs[i].size();
  for (int ii=0 ; ii<num1 ; ii++)
      {
      num2 = site_templs[i][ii].size();
      for (int iii=0 ; iii<num2 ; iii++) buf[m++] = site_templs[i][ii][iii];
      printf (" B  m = %d   num2=%d\n",m,num2);
      }
  
  num1 = buf[m++] = all_templs[i].size();
  for (int ii=0 ; ii<num1 ; ii++) buf[m++] = all_templs[i][ii];
  printf (" C  m = %d\n",m);
  
  // site arrays kopieren.
  int numSites = type2numSites[atom->type[i]];
  for (int ii=0 ; ii<numSites ; ii++)
      {
      buf[m++] = site_bound_tag [i][ii];
      buf[m++] = site_modified  [i][ii];
      buf[m++] = site_bond_id   [i][ii];
      buf[m++] = site_other_site[i][ii];
      printf (" D  m = %d\n",m);
      }
      
  // visitation:       // I don't think we should have to use this:
  assert( visited[i] == -1 );    // if this hurts, uncomment the next line:
  //visited[j] = visited[i];
  
  buf[m++] = refractory[i];
  
  
  buf[0] = m;
//  assert (false);   // ... not yet implemented!
  
  printf ("     bufsize = %d\n",m);
  return m;
}

/* ---------------------------------------------------------------------- */

int AtomVecSRSim::unpack_exchange(double *buf)
{
  int m = SUPERCLASS::unpack_exchange (buf);
  int j = atom->nlocal - 1;
  printf ("J = %d\n",j);
  assert(false);
  
  
  
  
  // add to amount_templs what will be in j:
  //for (int ii=0 ; ii<all_templs[j].size() ; ii++) amount_templs[ all_templs[j][ii] ]++;
  
  
  
  
  
  /*int j = atom->nlocal - 1;
  
  int jNum = num_fitting_templates[j] = static_cast<int> (buf[m++]);
  fitting_templates[j] = (int*) realloc (fitting_templates[j], sizeof(int)*jNum);  // realloc mem.
  for (int k=0 ; k<jNum ; k++)
      fitting_templates[j][k] = static_cast<int> (buf[m++]);                // write data
  num_fitting_overall += jNum;
  */
  
  //assert (false);   // ... not yet implemented!
  
  return m;
}

/* ----------------------------------------------------------------------
   size of restart data for all atoms owned by this proc
   include extra data stored by fixes
------------------------------------------------------------------------- */

int AtomVecSRSim::size_restart()
{
  int num = SUPERCLASS::size_restart();
      
  for (int i=0 ; i<atom->nlocal ; i++)
      {
      int nsi = type2numSites[atom->type[i]];
      num += 1 + nsi*4;
      }
  
  
  
  //assert (false);   // ... not yet implemented!
  printf (" :::  Restart size ;= %d \n",num);
  
  return num;
}

/* ----------------------------------------------------------------------
   pack atom I's data for restart file including extra quantities
   xyz must be 1st 3 values, so that read_restart can test on them
   molecular types may be negative, but write as positive   
------------------------------------------------------------------------- */

int AtomVecSRSim::pack_restart(int i, double *buf)
{
  int num = 0;
  num += SUPERCLASS::pack_restart(i,buf);
  
  /*for (int i=0 ; i<nlocal ; i++)
      {*/
      int nsi = type2numSites[atom->type[i]];
      for (int is=0 ; is<nsi ; is++)
          {
          buf[num++] = site_bond_id   [i][is];
          buf[num++] = site_other_site[i][is];
          buf[num++] = site_modified  [i][is];
          buf[num++] = site_bound_tag [i][is];
          }
      buf[num++] = refractory[i];
      //}
      
/*  for (int i=0 ; i<refractoryList.size() ; i++)
      {
      buf[num++] = refractory[i];
      }
      
  buf[num++] = rigid_system;
  buf[num++] = mol_Id_Cnt;
  */
  //assert (false);   // ... not yet implemented!
  
  printf (" ::::  Packing restart for %d \n",i);
  
  return num;
}

/* ----------------------------------------------------------------------
   unpack data for one atom from restart file including extra quantities
------------------------------------------------------------------------- */

int AtomVecSRSim::unpack_restart(double *buf)
{
  printf ("unpacking!!!\n");
  int num = SUPERCLASS::unpack_restart(buf);
  
  int i   = atom->nlocal-1;
  int nsi = type2numSites[atom->type[i]];
  
  site_templs    [i].resize (nsi);
  
  visited        [i] = -1;
  site_bond_id   [i] = (int*) realloc( NULL/*site_modified[nlocal]*/ , nsi*sizeof(int) );
  site_other_site[i] = (int*) realloc( NULL/*site_modified[nlocal]*/ , nsi*sizeof(int) );
  site_modified  [i] = (int*) realloc( NULL/*site_modified[nlocal]*/ , nsi*sizeof(int) );
  site_bound_tag [i] = (int*) realloc( NULL/*site_bound_to[nlocal]*/ , nsi*sizeof(int) );
    
  for (int is=0 ; is<nsi ; is++)
      {
      site_bond_id   [i][is] = (int)buf[num++];
      site_other_site[i][is] = (int)buf[num++];
      site_modified  [i][is] = (int)buf[num++];
      site_bound_tag [i][is] = (int)buf[num++];
      }
  refractory[i] = (int)buf[num++];
    
  return num;
}

/* ----------------------------------------------------------------------
   create one atom of itype at coord
   set other values to defaults
------------------------------------------------------------------------- */

void AtomVecSRSim::create_atom(int itype, double *coord)
  {
  if (srmodel == NULL)
     error->all("The rule system is not initialized yet: use runmodif_srsim ruleSys first! (e.g. runmodif_srsim ruleSys spass.bngl spass.geo spass.tgeo 12345)");
  
  //printf ("AtomVecSRSim::create_atom: \n");
  SUPERCLASS::create_atom(itype, coord);
  //printf ("   invoked superclass!\n");
  
  int nlocal = atom->nlocal - 1;
  if (nlocal%1000 == 0) printf ("AtomVecSRSim::create_atom : created %d atoms.\n",nlocal);
  
  visited              [nlocal] = -1;
  refractory           [nlocal] = -1;
  //printf ("   visited!\n");
  
  int numSites = type2numSites[ itype ];
  //printf ("   A!\n");
  site_bound_tag [nlocal] = (int*) realloc( NULL/*site_bound_to[nlocal]*/ , numSites*sizeof(int) );
  site_modified  [nlocal] = (int*) realloc( NULL/*site_modified[nlocal]*/ , numSites*sizeof(int) );
  site_bond_id   [nlocal] = (int*) realloc( NULL/*site_modified[nlocal]*/ , numSites*sizeof(int) );
  site_other_site[nlocal] = (int*) realloc( NULL/*site_modified[nlocal]*/ , numSites*sizeof(int) );
  //printf ("   CV!\n");
  for (int i=0 ; i<numSites ; i++)
      {site_bound_tag [nlocal][i]=-1; 
       site_modified  [nlocal][i]=-666;            // -666 for initial, unset value!
       site_bond_id   [nlocal][i]=-1; 
       site_other_site[nlocal][i]=-1; 
       }
  //printf ("   sbt & smod vergroessert für numsites=%d!\n", numSites);
      
  site_templs[nlocal].resize (numSites);
  //printf ("   site_templs vergroessert für numsites=%d!\n", numSites);
  
  atom->nspecial[nlocal][0] = 0;   // Why do we need to do this??? I don't know?!
  atom->nspecial[nlocal][1] = 0;   //   I don't even know what this nspecial is all about!!
  atom->nspecial[nlocal][2] = 0;
  //printf ("AtomVecSRSim::create_atom... done creating Atom.\n");
  }

/* ----------------------------------------------------------------------
   unpack one line from Atoms section of data file
   initialize other atom quantities
------------------------------------------------------------------------- */

void AtomVecSRSim::data_atom(double *coord, int imagetmp, char **values)
{
  if (srmodel == NULL)
     error->all("The rule system is not initialized yet: use runmodif_srsim ruleSys first! (e.g. runmodif_srsim ruleSys spass.bngl spass.geo spass.tgeo 12345)");
  
  SUPERCLASS::data_atom (coord, imagetmp, values);

  printf ("Data Atom1\n");
  int nlocal = atom->nlocal - 1;
      
  visited              [nlocal] = -1;
  refractory           [nlocal] = -1;
  
  int numSites = type2numSites[ atom->type[nlocal] ];
  printf ("Data Atom2 ; type=%d ; nlocal=%d ; numSites=%d\n", atom->type[nlocal], nlocal, numSites);
  site_bound_tag [nlocal] = (int*) realloc( NULL/*site_bound_to[nlocal]*/ , numSites*sizeof(int) );
  site_modified  [nlocal] = (int*) realloc( NULL/*site_modified[nlocal]*/ , numSites*sizeof(int) );
  site_bond_id   [nlocal] = (int*) realloc( NULL/*site_modified[nlocal]*/ , numSites*sizeof(int) );
  site_other_site[nlocal] = (int*) realloc( NULL/*site_modified[nlocal]*/ , numSites*sizeof(int) );
  for (int i=0 ; i<numSites ; i++)
      {site_bound_tag [nlocal][i]=-1; 
       site_modified  [nlocal][i]=-1;
       site_bond_id   [nlocal][i]=-1; 
       site_other_site[nlocal][i]=-1; 
       }
      
  site_templs[nlocal].resize (numSites);
  printf ("Data Atom3\n");
}

/* ----------------------------------------------------------------------
   unpack hybrid quantities from one line in Atoms section of data file
   initialize other atom quantities for this sub-style
------------------------------------------------------------------------- */

int AtomVecSRSim::data_atom_hybrid(int nlocal, char **values)
{
  assert( false );
  return SUPERCLASS::data_atom_hybrid(nlocal, values);
}

/* ----------------------------------------------------------------------
   return # of bytes of allocated memory 
------------------------------------------------------------------------- */

double AtomVecSRSim::memory_usage()
{
  double bytes = SUPERCLASS::memory_usage();
  
  bytes += (nmax * 50)*sizeof(int);
  
  return bytes;
}







/** ----------------------------------------------------------------------
 *  finds a fitting site of a molecule...
 *    until now, it's just taking the first site with the right type & modification.
 *
 *  idx                Lammps atom index
 *  needType  = -1     don't care for site type
 *  needModif = -1     don't care for modification.
 * ----------------------------------------------------------------------- */
vector<int> LAMMPS_NS::AtomVecSRSim::findAllFittingSites( int idx, int needType, int needModif, bool needFree )
  {
  SRSim_ns::MoleculeTypeManager *mtm = srmodel->mtm;
  int myType   = atom->type[idx];
  int numSites = type2numSites[myType];

  vector<int> sites;
    
  //printf (" Searching for: idx:%d stp:%d mod:%d free:%d \n",idx, needType, needModif, needFree);
  for (int i=0 ; i<numSites ; i++)
      {
      //printf ("   mtp:%d Site-%d: stp:%d mod:%d boundTo:%d \n", myType, i, mtm->getSiteType(myType,i), site_modified[idx][i], site_bound_to[idx][i]);
      
      if ( mtm->getSiteType(myType,i) != needType && needType !=-1) continue;
      if ( needModif != site_modified[idx][i]     && needModif!=-1) continue;
      if ( needFree  != (site_bound_tag[idx][i]==-1) )              continue;
      sites.push_back( i );    // ok, found.
      
      //printf ("      Taking site %d \n", i);
      }
      
      
  assert (sites.size() > 0);  // when the template says it fits, there 
                              //  should really be at least one fitting site!
  //printf (" Done AtomVecSRSim::findAllFittingSites. Found %d sites. \n",sites.size());
  return sites;
  }
  
/** ----------------------------------------------------------------------
 *  finds a fitting site of a molecule...
 *       ... by the fitting site_templs...
 * ----------------------------------------------------------------------- */
int LAMMPS_NS::AtomVecSRSim::findFittingSite( int idx, int needTemplate )
  {
  int myType      = atom->type[idx];
  int numSites    = type2numSites[myType];
  
  for (int i=0 ; i<numSites ; i++)
      {
      int numTempls = site_templs[idx][i].size();
      
      // ------- begin: only for testing ------
      // TODO: remove this stuff...
      /*bool found=false;
      for (int j=0 ; j<numTempls ; j++)
          if (needTemplate == site_templs[idx][i][j])
             {
             if (! found) found=true;
             else         assert (false);      // here are two fitting sites: we should rather randomize!
             }*/
      // ------- end: only for testing ------
      
      for (int j=0 ; j<numTempls ; j++)
          if (needTemplate == site_templs[idx][i][j])
             return i;    // this may be the first, not the only site...
      }
      
  assert (false);  // we do not want to reach this place!!!
  return -1;
  }

/** ----------------------------------------------------------------------
 *  wich Other molecule is linked to molecule 'idx' at site 'site'
 *    returns the local idx, not the tag.
 * ----------------------------------------------------------------------- */
int LAMMPS_NS::AtomVecSRSim::findOtherEnd( int idx, int site )
  {
  int nextTag = site_bound_tag[idx][site];
  assert (nextTag != -1);  // would be unbound!
  
  // idx of the next Molecule:
  int nextIdx = atom->map(nextTag);
  
  return nextIdx;
  }


// int LAMMPS_NS::AtomVecSRSim::findSiteByTargetTag( int idx, int targetTag )
//   {
//   assert( false );   // this is an old and evil method. should not be used!!
//   
//   int type     = atom->type[idx];
//   int numSites = type2numSites[type];
//   for (int site=0 ; site<numSites ; site++)
//       {
//       /*if (update->ntimestep == 13843)
//          {
//          string sname = srmodel->names->getName(SRSim_ns::NamesManager::SiteName, srmodel->mtm->getSiteType(type, site));
//          printf ("  site %d   [%s]\n", site, sname.c_str());   
//          }*/
//       
//       int sbt = site_bound_to[idx][site];
//           
//       if (sbt == -1)   continue;
//       if (sbt <= -100) sbt = -sbt-100;
//       else             sbt = atom->bond_atom[idx][sbt];// if (sbt>=0)
//       
//       /*if (update->ntimestep == 13843)
//          {
//          printf ("    idx=%d  tgt=%d  sbt==%d   smod==%d\n", idx, targetTag, sbt, site_modified[idx][site]);   
//          }*/
//       
//       if (sbt == targetTag) return site;
//       }
//       
//   //printf ("AtomVecSRSim::findSiteByTargetTag: searching in %d for tag %d!\n",idx, targetTag);
//       
//   assert (false);  // when this function is called an appropriate site really should exist!
//   return -1;
//   }

bool LAMMPS_NS::AtomVecSRSim::fitsToTemplate( int idx, int needTemplate )
  {
  int numTempls = all_templs[idx].size();
  for (int i=0 ; i<numTempls ; i++)
      if (all_templs[idx][i] == needTemplate) return true;
      
  return false;
  }

void AtomVecSRSim::recVisit( int idx, SRSimCallback *cback, int depth, int maxDepth)
  {
  //printf ("AtomVecSRSim::recVisit of idx=%d in depth=%d\n", idx, depth);
  assert (visited[idx] == -1);  // should be unvisited.
  visited[idx] = depth; // ok, we won't check this one again.
  visitedStack.push( idx );
  
  // calculate something if we want to...
  if (cback != NULL) cback->run(idx);

  // maybe we have already reached the last last level of detail...
  if (maxDepth!=-1 && depth >= maxDepth) return;
    
  // check the molecules connected to this one:  
  int type     = atom->type[idx];
  int numSites = type2numSites[type];
  for (int i=0 ; i<numSites ; i++)
      {
      //printf ("  looking at site: %d    sbt: %d\n", i, avec->site_bound_to[startIdx][i]);
      if (site_bound_tag[idx][i] == -1) continue;
      int sbt = findOtherEnd(idx,i);
         
      //printf ("  has %d been visited: %d\n", sbt, visited[sbt]);
      if (visited[sbt] == -1) 
         {
         //printf ("  __going rec to %d here.\n",sbt);
         recVisit( sbt, cback, depth+1 );
         }
      }
  
  }

void AtomVecSRSim::unVisitAll( )
  {
  while (! visitedStack.empty())
     {
     int i = visitedStack.top();
             visitedStack.pop();
     //printf ("delling visitation of %d.\n",i);
     visited[i] = -1;
     }
  }

  
  
/**
 *    The Bond-Type is 1 for now... we'll need to add geometry some time later...
 *
 *  //  the mol with smaller tag will be i, the one with the grear tag j.
 *  //   mol i will link to mol j.
 */
void AtomVecSRSim::addNewBond (int i, int j_tag, int i_site, int j_site)
  {
  int j        = atom->map(j_tag);
  int i_tag    = atom->tag[i];
  int i_type   = atom->type[i];
  int j_type   = atom->type[j];
    
  int bondType = srmodel->geo->getBondId( i_type, j_type, i_site, j_site ) + 1;    // + 1 as lammps types begin with 1
  
  //printf ("adding new bond... of Type %d, length is %f, t%d t%d   between %d and %d.\n", bondType, srmodel->geo->getBondDistance(bondType-1), i_type,j_type, i,j);
  
  // Lammps-Bond:
  int oldMeng = atom->num_bond[i];
  assert (oldMeng+1 <= atom->bond_per_atom);
  atom->bond_atom[i][oldMeng] = j_tag;
  atom->bond_type[i][oldMeng] = bondType;           //printf ("  Old Meng = %d \n", oldMeng);
  atom->num_bond [i]++;
  atom->nbonds      ++;
  
  // Site Bond:
  //site_bound_to[i][i_site] = oldMeng;
  //site_bound_to[j][j_site] = -(100+i_tag);
  site_bound_tag [i][i_site] = j_tag;
  site_other_site[i][i_site] = j_site;
  site_bond_id   [i][i_site] = oldMeng;
  
  site_bound_tag [j][j_site] = i_tag;
  site_other_site[j][j_site] = i_site;
  site_bond_id   [j][j_site] = -1;

  // reset the angles:
  activateAngles( i );
  activateAngles( j );
    
  
/*  if (i==1754 && j==1671 && update->ntimestep > 8000)
     {
     printf ("###############\n#################\n#############\n###############\n");
     printf ("AtomVecSRSim::addNewBond   i %d, j %d \n",i,j);
     printf ("AtomVecSRSim::addNewBond   iSite=%d  jSite=%d \n", i_site,j_site);
     printf ("AtomVecSRSim::addNewBond   iSBT=%d  jSBT=%d \n", site_bound_to[i][i_site],site_bound_to[j][j_site] );
     printf ("###############\n#################\n#############\n###############\n");
     assert (false);
     }*/
  
  /*if (update->ntimestep == 13592 || i==1754)
     {
     printf ("###############\n#################\n#############\n###############\n");
     printf ("AtomVecSRSim::addNewBond   i %d, j %d \n",i,j);
     printf ("AtomVecSRSim::addNewBond   iSite=%d  jSite=%d \n", i_site,j_site);
     printf ("AtomVecSRSim::addNewBond   iSBT=%d  jSBT=%d \n", site_bond_id[i][i_site],site_bond_id[j][j_site] );
     printf ("###############\n#################\n#############\n###############\n");
     //assert (false);
     }*/
  
  //printf ("Done.\n");
  //printf ("adding new bond... (%d-%d)  bType=%d  oldM=%d nb=%d  sbt_i=%d sbt_j=%d  nBonds=%d\n",i,j, bondType, oldMeng, atom->num_bond[i],site_bound_to[i][i_site], site_bound_to[j][j_site], atom->nbonds);
  
/*  if (i==422 || j==422)
     {
     printf ("Aber Hallo! i=%d j=%d\n",i,j);
            LammpsMolecule l(422);
            l.writeToDotFile ("mol422.dot");
     assert (false);
     }*/
  }
  
/**
 *   1 x bond_atom shifting to the left
 *   2 x del site_bound_to
 *
 *   if (sbt <= -100)
 *
 *   idx : site which does the bind:
 */
void AtomVecSRSim::breakBond( int i, int site )
  {
  //int sbt = site_bound_tag[i][site];
  
  int masterIdx , slaveIdx;
  int masterSite, slaveSite;
  int masterBond;
  
  //printf ("Trying to break bond i=%d, s=%d,  \n",i,site);

  assert (site_bound_tag[i][site] != -1);   // then it would already be unbound!
  if (site_bond_id[i][site] != -1)
     {
     masterIdx = i; masterSite = site; masterBond = site_bond_id[i][site];
     slaveIdx = atom->map( site_bound_tag[masterIdx][masterSite] );
     
     // now missing: slaveSite
     slaveSite = site_other_site[masterIdx][masterSite];
     }
  else // i ist slave, nicht master
     {
     slaveIdx = i; slaveSite = site;
     masterIdx = atom->map( site_bound_tag[slaveIdx][slaveSite] );  // now the id of the L.b.a.
     masterSite = site_other_site[slaveIdx][slaveSite];
     masterBond = site_bond_id[masterIdx][masterSite];
     }

  //printf ("  SIdx:%d SSt:%d   MIdx:%d MSt:%d\n ", slaveIdx, slaveSite, masterIdx, masterSite);
  //printf ("MasterBond = %d   ... trying to break %d\n ", masterBond, i);
  assert (masterBond >= 0);
  
  // delete master's bond_atom: shift the values from behind to the left
  //  ALSO: we'll have to adjust some site_bound_to values now!
  int oldMeng  = atom->num_bond [masterIdx];
  int mType    = atom->type[masterIdx];
  int numSites = type2numSites[mType];
  for (int ii=masterBond+1 ; ii<oldMeng ; ii++)
      atom->bond_atom[masterIdx][ii-1] = atom->bond_atom[masterIdx][ii];
  for (int ii=masterBond+1 ; ii<oldMeng ; ii++)
      atom->bond_type[masterIdx][ii-1] = atom->bond_type[masterIdx][ii];
  atom->num_bond [masterIdx]-- ;
  atom->nbonds              --;

  // now we'll probably have some left over site_bond_id's, which is bad.
  for (int ii=0 ; ii<numSites ; ii++)
      if (site_bond_id[masterIdx][ii] > masterBond)           // Otherwise our sites will point to wrong atoms!
         site_bond_id[masterIdx][ii]--;
         
  
  /*if (masterIdx==1754)
     {
     printf ("~~~~~~~~~~~~~~\n~~~~~~~~~~~~~~~~~\n~~~~~~~~~~~~~~~\n~~~~~~~~~~~~~~\n");
     printf ("AtomVecSRSim::breakBond   i %d, j %d \n",masterIdx,slaveIdx);
     printf ("AtomVecSRSim::breakBond   iSite=%d  jSite=%d \n", masterSite,slaveSite);
     printf ("AtomVecSRSim::breakBond   iSBT=%d  jSBT=%d \n", site_bond_id[masterIdx][masterSite],site_bond_id[slaveIdx][slaveSite] );
     printf ("~~~~~~~~~~~~~~\n~~~~~~~~~~~~~~~~~\n~~~~~~~~~~~~~~~\n~~~~~~~~~~~~~~\n");
     assert (false);
     }*/
  
  // free sites:
  site_bond_id   [masterIdx][masterSite] = -1;
  site_bound_tag [masterIdx][masterSite] = -1;
  site_other_site[masterIdx][masterSite] = -1;
  
  site_bond_id   [ slaveIdx][ slaveSite] = -1;
  site_bound_tag [ slaveIdx][ slaveSite] = -1;
  site_other_site[ slaveIdx][ slaveSite] = -1;
  
  // reset the angles:
  activateAngles( masterIdx );
  activateAngles( slaveIdx );
    
  // that's it.
  //printf ("Deleted bond: (%d -- %d)\n", masterIdx, slaveIdx);
  }
  
  

/*void LAMMPS_NS::AtomVecSRSim::addTemplate2Sim( SRSim_ns::ReactantTemplate * rt, double x, double y, double z )
  {
  assert (false);
  
  // maybe we'll have to grow:
  //printf ("before nmax = %d  nlocal = %d\n", atom->nmax, atom->nlocal);
  // Nope - AtomVecAngle does the growing thingy...!
  
  // We should:
  //    determine if it's the right machine!!
  assert (comm->me == 0);
  
  // add:
  double dat[] = {x,y,z};
  create_atom(2, dat);
  
  //atom->tag[atom->nlocal-1] = 3;
  
  //printf ("after nmax = %d  nlocal = %d  \n", atom->nmax, atom->nlocal);
  
  // new total # of atoms
  //double nlocal = atom->nlocal;
  //MPI_Allreduce(&nlocal,&atom->natoms,1,MPI_DOUBLE,MPI_SUM,world);
  atom->natoms = atom->nlocal;
  
  // clean up: 
  // I don't know why to do it this way, but that's what create_atoms.cpp does!
  assert (atom->natoms <= 0x7FFFFFFF);   // MAXATOMS from create_atoms.cpp, line 28
  assert (atom->map_style == 1);         // means a map-array!
  atom->tag_extend();
  atom->map_init();
  atom->map_set();
  //assert (!atom->molecular);
  }*/

  
void LAMMPS_NS::AtomVecSRSim::activateAngles( int idx )
  {
  SRSim_ns::GeometryDefinition *geo = srmodel->geo;
  
  int type          = atom->type[idx];
  int numSites      = type2numSites[type];
  int nAnglesBefore = atom->num_angle[idx];
  
  // which bonds do we have?
  vector<int> bonds;
  for (int i=0 ; i<numSites ; i++) if (site_bound_tag[idx][i] != -1) bonds.push_back( i );
  
  // we don't need an Angle for one bond!
  if (bonds.size() <= 1) 
     {
     atom->nangles -= nAnglesBefore;
     atom->num_angle[idx] = 0;
     //printf ("\n\n\n\n\n  atom->nangles = %d  (having added %d angles!) \n\n\n\n\n\n", atom->nangles, -nAnglesBefore);
     return;
     }
     
  // having two bonds:
  int cnt=0;
  /*if (bonds.size() >= 2)
     {
     atom->angle_type [idx][cnt] = 1 + geo->getAngleId( type, bonds[0], bonds[1] );
     atom->angle_atom1[idx][cnt] = atom->tag[ findOtherEnd( idx, bonds[0] ) ];
     atom->angle_atom2[idx][cnt] = atom->tag[ idx                           ];
     atom->angle_atom3[idx][cnt] = atom->tag[ findOtherEnd( idx, bonds[1] ) ];
     cnt++;
     
     //printf ("   ... AnglyType = %d!  Meaning ?? degrees!\n", atom->angle_type[idx][0]);
     }*/
     
  // having even more bonds:
  /*for (int k=2 ; k < bonds.size() ; k++)
      {
      atom->angle_type [idx][cnt] = 1 + geo->getAngleId( type, bonds[0], bonds[k] );
      atom->angle_atom1[idx][cnt] = atom->tag[ findOtherEnd( idx, bonds[0] ) ];
      atom->angle_atom2[idx][cnt] = atom->tag[ idx                           ];
      atom->angle_atom3[idx][cnt] = atom->tag[ findOtherEnd( idx, bonds[k] ) ];
      cnt++;
      
      atom->angle_type [idx][cnt] = 1 + geo->getAngleId( type, bonds[1], bonds[k] );
      atom->angle_atom1[idx][cnt] = atom->tag[ findOtherEnd( idx, bonds[1] ) ];
      atom->angle_atom2[idx][cnt] = atom->tag[ idx                           ];
      atom->angle_atom3[idx][cnt] = atom->tag[ findOtherEnd( idx, bonds[k] ) ];
      cnt++;
      }*/
      
  // addition of all possible bonds:
  for (int k=0 ; k < bonds.size() ; k++)
      for (int kk=k+1 ; kk < bonds.size() ; kk++)
          {  
          // sind wir ein rigid-body system?
          int p1   = findOtherEnd( idx, bonds[k]  );
          int mol1 = atom->molecule[idx];
          int p3   = findOtherEnd( idx, bonds[kk] );
          
          if (rigid_system)
             {
             int mol1 = atom->molecule[idx];
             //printf ("Mol = %d,%d,%d \n", mol1, atom->molecule[findOtherEnd( idx, bonds[k] )], atom->molecule[findOtherEnd( idx, bonds[kk] )]);
             if (mol1 == atom->molecule[p1] && mol1 == atom->molecule[p3])
                continue;
             }
          
          
          atom->angle_type [idx][cnt] = 1 + geo->getAngleId( type, bonds[k], bonds[kk] );
          atom->angle_atom1[idx][cnt] = atom->tag[ p1  ];
          atom->angle_atom2[idx][cnt] = atom->tag[ idx ];
          atom->angle_atom3[idx][cnt] = atom->tag[ p3 ];
          
          //printf ("   ... AnglyType = %d!  Meaning ?? degrees!\n", atom->angle_type[idx][cnt]);
          cnt++;
          }
  
  atom->nangles += cnt - nAnglesBefore ;
  atom->num_angle[idx] = cnt;
  //printf ("\n\n\n\n\n  atom->nangles = %d  (having added %d angles!) \n\n\n\n\n\n", atom->nangles, cnt - nAnglesBefore);
  }

  
  
void LAMMPS_NS::AtomVecSRSim::refractMol( int i, int until_ts )
  {
  //printf ("  Marking %d as refractory until %d \n",i,until_ts);
  if (refractory[i] != -1) 
     {
     // we'll first have to delete i from the list, then push it onto the end again!#
     refractoryList.remove( i );
     }
  //assert( refractory[i] == -1 );
  
  refractory[i] = until_ts;
  refractoryList.push_back( i );
  }
  
void LAMMPS_NS::AtomVecSRSim::unRefract( )
  {
  //printf ("DeRefracting in ts %d.    (%d refractory molecules)\n", update->ntimestep, refractoryList.size() );
  while (! refractoryList.empty() )
     {
     int ts = refractory[ refractoryList.front() ];
     if (ts > update->ntimestep) return;
     
     // we have to delete this one:
     refractory[ refractoryList.front() ] = -1;
     refractoryList.pop_front();
     }
  }


void LAMMPS_NS::AtomVecSRSim::addTemplate2Sim( SRSim_ns::ReactantTemplate * rt, double x, double y, double z )
  {
  if (srmodel == NULL)
     error->all("The rule system is not initialized yet: use runmodif_srsim ruleSys first! (e.g. runmodif_srsim ruleSys spass.bngl spass.geo spass.tgeo 12345)");
  
  SRSim_ns::MoleculeTypeManager *mtm = srmodel->mtm;
  
  int myMolID = mol_Id_Cnt++;

  // what are we going to do in muliproc-usage?
  assert( comm->me == 0 );
      
  assert( rt->getGeo() != NULL );
  
  assert( rt->isUsableAs(SRSim_ns::ReactantTemplate::creatableRT) );
  //assert( false );

  double x0 = domain->sublo[0], xm = domain->subhi[0];
  double y0 = domain->sublo[1], ym = domain->subhi[1];
  double z0 = domain->sublo[2], zm = domain->subhi[2];
    
  // add:
  int nOld = atom->nlocal;                         // the old local atom count...
  for (int m=0 ; m<rt->numMolecules() ; m++)
      {
      SRSim_ns::TemplMolecule   *tm    = rt->getMolecule(m);
      int                        mType = tm->getType();
      SRSim_ns::Coords           co    = rt->getGeo()->getCoords(m);
      
      // are all sites of this molecule defined?
      if (tm->numSites() != mtm->numSites(tm->getType()))
         printf("############\n  Warning: in Template %s not all sites are defined as they should be!\n##########\n", rt->getName().c_str() );
      
      tm->setRealization (m);
      
      // Gerdl: what was this one for?
      if (x+co.x[0] < x0) x -= x+co.x[0] - x0 - 0.01;
      if (y+co.x[1] < y0) y -= y+co.x[1] - y0 - 0.01;
      if (z+co.x[2] < z0) z -= z+co.x[2] - z0 - 0.01;
      if (x+co.x[0] > xm) x -= x+co.x[0] - xm + 0.01;
      if (y+co.x[1] > ym) y -= y+co.x[1] - ym + 0.01;
      if (z+co.x[2] > zm) z -= z+co.x[2] - zm + 0.01;
      
      assert(x+co.x[0]>=x0);
      assert(y+co.x[1]>=y0);
      assert(z+co.x[2]>=z0);
      assert(x+co.x[0]<=xm);
      assert(y+co.x[1]<=ym); //printf ("z = %f   co = %f\n",z,co.x[2]);
      assert(z+co.x[2]<=zm);
      
      double dVect[] = {x+co.x[0], y+co.x[1], z+co.x[2]};
      create_atom(mType, dVect);
      
      atom->molecule[atom->nlocal-1] = myMolID;  // so rigid body dynamics can be used.
      }
  
  
  //printf ("after nmax = %d  nlocal = %d  \n", atom->nmax, atom->nlocal);
  
  // new total # of atoms
  //double nlocal = atom->nlocal;
  //MPI_Allreduce(&nlocal,&atom->natoms,1,MPI_DOUBLE,MPI_SUM,world);
  assert (comm->me == 0);
  atom->natoms = atom->nlocal;
  
  // clean up: 
  // I don't know why to do it this way, but that's what create_atoms.cpp does!
  assert (atom->natoms <= 0x7FFFFFFF);   // MAXATOMS from create_atoms.cpp, line 28
  assert (atom->map_style == 1);         // means a map-array!
  atom->tag_extend();
  atom->map_init();
  atom->map_set();
    
  // let's do the bonding and site modifications:
  for (int m=0 ; m<rt->numMolecules() ; m++)
      {
      SRSim_ns::TemplMolecule *tm = rt->getMolecule(m);
      tm->setRealization( -1 );
      for (int s=0 ; s<tm->numSites() ; s++)
          {
          // site modification?
          bool modified = false;
          int rmSiteCount = mtm->numSites(tm->getType());
          for (int rms=0 ; rms < rmSiteCount ; rms++)            // searching for the right site to modify:
              {
              //printf ("Searching for Site %d and this is %d [M%d S%d RMS%d]\n",tm->getSiteType(s), mtm->getSiteType(tm->getType(),rms), m,s,rms );
              
              if (site_modified[nOld+m][rms]          != -666)               continue;
              if (mtm->getSiteType(tm->getType(),rms) != tm->getSiteType(s)) continue;
              site_modified[nOld+m][rms] = tm->getModificationAtSite(s);
              modified = true;
              //printf ("    mod[%d][%d] = %d\n", nOld+m, rms, avec->site_modified[nOld+m][rms] );
              break;
              }
          assert( modified );
          
          // bonding:          
          SRSim_ns::TemplMolecule *tm2 = dynamic_cast<SRSim_ns::TemplMolecule*>( tm->getMoleculeAtSite(s) );
          if (tm2 == NULL)                 continue;
          if (tm2->getRealization() == -1) continue;
          
          int sType2 = tm->getSite(s)->getOther()->getType();
          
          int rea1  = nOld + m;
          int rea2  = nOld + tm2->getRealization();

          int site1 = findAllFittingSites (rea1, tm ->getSiteType(s), -1/*needModif*/, true/*needFree*/)[0];
          int site2 = findAllFittingSites (rea2, sType2             , -1/*needModif*/, true/*needFree*/)[0];
          
          addNewBond(rea1, atom->tag[rea2], site1, site2);
          }
          
      // Do all mol-sites have their proper modifications? None is -666?
      for (int rms=0 ; rms<mtm->numSites(tm->getType()) ; rms++)
          if (site_modified[nOld+m][rms] == -666) site_modified[nOld+m][rms] = -1;
      }
  
  }


